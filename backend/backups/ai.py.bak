from fastapi import APIRouter, Depends, HTTPException, Request, Response
from ..routes.auth import get_current_user
from ..models.user import UserResponse
from ..models.chat import ChatRequest, ChatResponse, MealSuggestionRequest, MealSuggestionResponse
from ..services.unified_ai_service import unified_ai_service
from typing import Dict, Any, Callable
from pydantic import BaseModel
import logging

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/ai", tags=["ai"])

# Custom dependency to ensure CORS headers are added to AI endpoint responses
async def ensure_cors_headers(request: Request) -> None:
    """Dependency that logs AI endpoint requests and ensures CORS headers will be added"""
    # Log the request for debugging
    logger.info(f"AI endpoint accessed: {request.url.path} from origin: {request.headers.get('origin', 'unknown')}")
    # The actual header addition happens in the enhanced_cors_middleware in main.py
    # This is just for logging and debugging purposes
    return None


class MealPlanRequest(BaseModel):
    duration: int = 7
    meals_per_day: int = 3
    budget: str = "moderate"
    prep_time: str = "moderate"
    variety: str = "high"
    special_requests: str = ""


class HealthInsightRequest(BaseModel):
    analysis_period: int = 30  # days


@router.post("/chat", response_model=ChatResponse)
async def chat_with_assistant(
    request: ChatRequest,
    current_user: UserResponse = Depends(get_current_user)
):
    """Enhanced chat with AI nutrition assistant with full context awareness"""
    try:
        response = await unified_ai_service.chat_with_context(request, current_user.uid)
        return response
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Chat service error: {str(e)}")


@router.post("/meal-suggestions", response_model=MealSuggestionResponse)
async def get_meal_suggestions(
    request: MealSuggestionRequest,
    current_user: UserResponse = Depends(get_current_user),
    _: None = Depends(ensure_cors_headers)
):
    """Get AI-generated meal suggestions with enhanced user context"""
    try:
        # Use unified AI service with enhanced context
        suggestions = await unified_ai_service.get_smart_meal_suggestions(request, current_user.uid)
        return suggestions
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Meal suggestion service error: {str(e)}")


@router.post("/meal-plan")
async def generate_meal_plan(
    request: MealPlanRequest,
    current_user: UserResponse = Depends(get_current_user)
) -> Dict[str, Any]:
    """Generate comprehensive AI-powered meal plan"""
    try:
        plan_data = {
            "duration": request.duration,
            "meals_per_day": request.meals_per_day,
            "budget": request.budget,
            "prep_time": request.prep_time,
            "variety": request.variety,
            "special_requests": request.special_requests
        }
        
        meal_plan = await unified_ai_service.generate_intelligent_meal_plan(
            current_user.uid, 
            plan_data
        )
        
        # Remove any MongoDB-specific fields that might cause serialization issues
        if "_id" in meal_plan:
            del meal_plan["_id"]
        
        return meal_plan
    except Exception as e:
        print(f"Meal plan generation error for user {current_user.uid}: {str(e)}")
        print(f"Plan data: {plan_data}")
        raise HTTPException(status_code=500, detail=f"Meal plan generation error: {str(e)}")


@router.post("/health-insights")
async def get_health_insights(
    request: HealthInsightRequest,
    current_user: UserResponse = Depends(get_current_user)
) -> Dict[str, Any]:
    """Get comprehensive AI-powered health insights and analysis"""
    try:
        insights = await unified_ai_service.get_health_insights(current_user.uid)
        return insights
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Health insights error: {str(e)}")


@router.post("/smart-food-log")
async def smart_food_logging(
    message: str,
    current_user: UserResponse = Depends(get_current_user)
) -> Dict[str, Any]:
    """Process natural language food logging with AI assistance"""
    try:
        result = await unified_ai_service.process_food_operations(message, current_user.uid)
        return {"result": result, "message": "Food operations processed"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Smart food logging error: {str(e)}")


@router.get("/conversation-context")
async def get_conversation_context(
    current_user: UserResponse = Depends(get_current_user)
) -> Dict[str, Any]:
    """Get current conversation context for the user"""
    try:
        # Ensure conversation_contexts is initialized
        if not hasattr(unified_ai_service, 'conversation_contexts'):
            unified_ai_service.conversation_contexts = {}
        
        context = unified_ai_service.conversation_contexts.get(current_user.uid, {})
        
        # Convert any ObjectIds to strings to avoid serialization issues
        def clean_context(obj):
            if isinstance(obj, dict):
                return {k: clean_context(v) for k, v in obj.items()}
            elif isinstance(obj, list):
                return [clean_context(item) for item in obj]
            elif hasattr(obj, '__class__') and 'ObjectId' in str(obj.__class__):
                return str(obj)
            else:
                return obj
        
        cleaned_context = clean_context(context)
        return {"context": cleaned_context, "user_id": current_user.uid}
    except Exception as e:
        print(f"Context retrieval error for user {current_user.uid}: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Context retrieval error: {str(e)}")


@router.delete("/conversation-context")
async def clear_conversation_context(
    current_user: UserResponse = Depends(get_current_user)
) -> Dict[str, Any]:
    """Clear conversation context for the user"""
    try:
        # Ensure conversation_contexts is initialized
        if not hasattr(unified_ai_service, 'conversation_contexts'):
            unified_ai_service.conversation_contexts = {}
        
        if current_user.uid in unified_ai_service.conversation_contexts:
            del unified_ai_service.conversation_contexts[current_user.uid]
        return {"message": "Conversation context cleared"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Context clearing error: {str(e)}")


@router.get("/chat/history")
async def get_chat_history(
    current_user: UserResponse = Depends(get_current_user)
) -> Dict[str, Any]:
    """Get user's AI chat session history"""
    try:
        # Get chat history from unified AI service
        history = await unified_ai_service.get_chat_history(current_user.uid)
        return {"sessions": history}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Chat history error: {str(e)}")
